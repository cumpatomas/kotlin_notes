### Computational Thinking

Computational thinking is a set of mental skills helping to see the problems as a set of complex information processes that we can transform 
into a particular set of instructions for a computer.

Approach every problem you encounter while learning a programming language as not only the 
opportunity to remember the syntax of the language but also as an opportunity to train computational thinking.

To do that, you can follow a simple algorithm:

**1- Describe the problem**\
What exactly needs to be done? What input data are you given and what does the desired outcome look like?\
**2- Identify the important details needed to solve this problem**\
Before thinking of a solution, make sure you take into account all the important aspects of the problem. The devil is in the details, and in case of programming, it hides in edge cases.\
**3- Decompose**\
Break the problem down into small, logical steps until you know exactly how to code each part of it.
4- Use these steps to create an algorithm that solves the problem
Connect the pieces of the problem in a way that would produce the desired outcome in all specified cases.\
**5- Evaluate the process**\
Usually, a problem has at least a few solutions, and it’s very useful to evaluate your idea to make sure you've chosen a way that is as efficient as possible.

Let’s elaborate on the main foundations of this skill, namely: a**bstraction, decomposition, pattern recognition, and evaluation**.

## Decomposition
Complex problems are easier to solve when we break them down into separate steps and subproblems. We do this all the time in our daily life as well. For example, if your goal is to make a pizza, you’d need to find a recipe, shop for all the relevant ingredients, heat the oven, make the dough, chop the toppings and finally bake the pizza for an appropriate amount of time. Breaking down a problem like that helps to focus on solving each subproblem separately (and maybe even reusing solutions other people came up with) and avoid being overwhelmed by the requirements.

Extracting and Generalizing patterns
Once the problem is decomposed our next step would be to look for patterns in the smaller subproblems. A pattern is a set of features in a task that is shared among more than one instance of the problem. For example, if you need to cook Pepperoni pizza, you’d need to make a flat pizza bottom. The bottom is a pattern shared among all the pizzas, so you can generalize this pattern and if you wish to later make Margherita you can reuse all the information and steps you took for preparing Pepperoni pizza.

Pattern recognition is based on the five key steps:

Identify common elements in problems or systems

Identify and interpret common differences in problems or systems

Identify individual elements within sub-problems

Describe patterns that have been identified

Make predictions based on identified patterns.

## Abstraction
Abstraction helps us generalize the solution by figuring out a model of a situation. We get rid of all the unnecessary details to focus on what’s actually important. One can say that a programming language is an abstraction. You use variables to perform operations instead of listing all the data these variables stand for every time.

It’s exactly the abstraction that helps us come up with a generalizable solution without writing a separate program for each variation of the problem.

If we come back to pizza, and try to apply abstraction we would say that for pizza to be a pizza it needs flat dough, sauce, and toppings.

The shape of the pizza and the fact that it has cheese would be unnecessary details since it is possible to imagine square pizza with no cheese.

Therefore if we abstract our pizza like a flat dough open pie with toppings and sauce we would be able to write one program to perform operations on all the pizzas, no matter their taste, shape, and vegan friendliness.

## Evaluation
Once you found a solution to your problem it is helpful to go through an evaluation checklist. At times your solution won’t work and this checklist can also help you to find out where you’ve gone wrong.

Make sure your solution is:

Easy to understand. Usually that is the case if the problem is decomposed well.

Complete. Your solution covers all the aspects of the problem. Remember, the devil is in the corner cases.

Efficient. Make sure you are making the best of the tools you have, in case of programming it can regard using appropriate syntax constructions. Speed is one of the most important markers of the solution’s efficiency and becomes incredibly important when writing production code.